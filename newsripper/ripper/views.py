"""Views for ripper app."""

from django.shortcuts import render
from django.shortcuts import redirect
from django.contrib import messages
from django.views.generic import ListView
from django.views.generic import DetailView
from django.views.generic import RedirectView

from .models import Article
from .models import get_model_for_url
from .exceptions import URLDoesNotExist
from .rip_tools import url_is_valid


class ArticleListView(ListView):
    """List view for Articles."""

    queryset = Article.objects.order_by("-article_time")
    context_object_name = "articles"
    paginate_by = 10


class ArticleRedirectView(RedirectView):
    """Taking an article linked by ID, redirects to that article using the URL."""

    permanent = False
    query_string = True
    # pattern_name = "ripper:article_detail"

    def get_redirect_url(self, pk):
        article = Article.objects.get(pk=pk)
        return article.get_absolute_url()


class ArticleDetailView(DetailView):
    """Detail view for an Article."""

    model = Article
    context_object_name = "article"

    def get_object(self, queryset=None):
        """Override that grabs an article using the URL argument,
        which is neither a pk nor a slug (as expected by Django defaults).
        """
        url = self.kwargs.get("url")
        return Article.objects.get_by_url(url)

    def get(self, request, *args, **kwargs):
        """Get an article!"""
        try:
            self.object = self.get_object()
        except Article.DoesNotExist:
            url = self.kwargs.get("url")
            if url is not None:
                url_part = (url[:50] + "...") if len(url) > 53 else url
                output = (
                    f"Article not found for <strong>{url_part}</strong>. "
                    "Please run the URL through the processing form first."
                )
            else:
                output = "Article not found. Please run the URL through the processing form first."
            messages.error(request, output)
            return redirect("ripper:index")
        context = self.get_context_data(object=self.object)
        return self.render_to_response(context)


def process_article(request):
    """Accepts POST, takes a given URL for an article, parses that article,
    then redirects to its article page.
    """
    if request.method != "POST" or request.POST.get("rip-url") is None:
        return redirect("ripper:index")

    url = request.POST["rip-url"]
    url_part = (url[:50] + "...") if len(url) > 53 else url
    if not url_is_valid(url):
        messages.error(
            request, f"URL <strong>{url_part}</strong> invalid. Please try another URL."
        )
        return redirect("ripper:index")

    article, created = _process_article_from_url(url)
    if created:
        # A new article was created. Save this, and inform of the success
        article.save()
        messages.info(
            request,
            f"Article <strong>{article.title}</strong> successfully ripped. Happy reading!",
        )
    else:
        # Article already existed. Warn of the re-do attempt. No save required.
        messages.warning(
            request, f"Article matching URL previously saved. Try re-processing?"
        )

    return redirect(article)


def reprocess_article(request):
    if request.method != "POST" or request.POST.get("article_id") is None:
        return redirect("ripper:index")

    article_id = request.POST["article_id"]
    try:
        article = Article.objects.get(id=article_id)
    except Article.DoesNotExist:
        messages.error(request, f"Article #{article_id} not found. Please try again.")
        return redirect("ripper:index")

    if article.manual:
        # Don't re-process a manually-processed one, or you could break stuff.
        messages.error(
            request,
            (
                "This Article was <strong>manually processed</strong>. "
                "Automated re-processing is not possible. "
                "Consider updating your parsers, removing this Article, "
                "and trying again from scratch."
            ),
        )
        return redirect(article)

    # Process the existing Article's URL, skipping the dupe check
    temp_article, _ = _process_article_from_url(article.url, check_duplicate=False)
    # Copy the contents of the temp_article into the existing one, then save it and redirect us
    article.copy_article(temp_article)
    article.save()
    messages.info(request, "Re-processing successful.")
    return redirect(article)


def _process_article_from_url(url, check_duplicate=True):
    """Helper method that processes an article at a given URL.

    Returns a tuple, (created, article).
    `created` returns True if a new Article was generated by this method.
    Otherwise, returns False, indicating the Article is a duplicate.

    If an Article already exists for the given URL, returns that instance from the database.
    Otherwise, processes a new Article and returns it.

    If `check_duplicate` is False, the check for an existing Article is skipped,
    and a new Article is processed every time. Defaults to True.
    """
    if check_duplicate:
        try:
            article = Article.objects.get_by_url(url)
        except Article.DoesNotExist:
            # If doesn't exist, continue to create a new one.
            pass
        else:
            return article, False

    # Process a new article
    ArticleClass = get_model_for_url(url)
    article = ArticleClass(url=url)
    article.process()
    # Return the article and True, for new article created
    return article, True


def delete_article(request):
    """Accepts POST, deletes the given Article, and redirects back to the home page."""
    if request.method != "POST" or request.POST.get("article_id") is None:
        return redirect("ripper:index")
    article_id = request.POST["article_id"]
    try:
        article = Article.objects.get(id=article_id)
    except Article.DoesNotExist:
        messages.error(
            request,
            f"Article <strong>#{article_id}</strong> not found. Please try again.",
        )
    else:
        title = str(article)
        article.delete()
        messages.info(request, f"Article <strong>{title}</strong> deleted.")
    return redirect("ripper:index")
